; **The Runtime**

; Reserved registers:
;   Register C = stack pointer - Points to next available stack address
;   Register D = link register - Address to return when called functions finishes

; The runtime code below sets up registers C and D and makes available an 'exit' and 'return' label. 'exit'
; does what you'd expect. It's meant to be used a jump target or return address when using the link register.
; 'return' will take the value in register D and jump to that address to resume code execution.
; The label "main" is called to begin user code.

; Functions are implemented by using what's known as a Wheeler jump. Basically, we edit the running
; code to change an address in a jump command. The address is retrieved from a known register so calling
; functions can set the return address to what they need. Labels are used liberally for return addresses.
; A stack is used to store link addresses when a subroutine has to call another subroutine. The original
; subroutine will then pop the stack and restore the original link address before returning.

; The stack begins at memory address 0xFFFE (0xFFFF is the print address so can't be used) and grows down.
; There is no mechanism to check for an "out-of-bounds" stack. It's fully possible for the stack to overrun existing
; memory if care is not taken.

; The exit labels are not resolved at link time since both the jump instruction and its definition are
; part of the same code. The main label is resolved at link time so it can be anywhere in the code.

; BEGIN - Runtime
; Setup registers
LOADI %C 0xFFFE
LOADI %D ~exit

; Run main function
; The "main" label is resolved at link time.
JMPA ~main

:exit
    HALT

; return will jump to the address in register F
:return
    ; Edit jump address in next instruction to the location in register D
    STRA %D ~$+5
    JMPA ~exit
; END - Runtime

; Main is normally provided by user code, but is here so this script doesn't run infinitely
:main
    JMPA ~exit
