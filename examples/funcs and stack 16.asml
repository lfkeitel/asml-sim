; This example program demontrates using a print function to print single characters to the screen.
; This example uses the experimental 16 bit address architecture.
; Only the lower address of labels are used since everything fits within the first 256 bytes of memory.
; This is purely for demonstration purposes.

; Reserved registers:
;   Register 0 = constant 0 - Used for unconditional jumps
;   Register A = constant -1 - Used to manipulate stack pointer
;   Register B = constant 1 - Used to manipulate stack pointer
;   Register C,D = stack pointer - Points to next available stack address
;   Register E,F = link register - Address to return when called functions finishes

; Functions are implemented by using what's known as a Wheeler jump. Basically, we edit the running
; code to change an address in a jump command. The address is retrieved from a known register so calling
; functions can set the return address to what they need. Labels are used liberally for return addresses.
; A stack is used to store link addresses when a subroutine has to call another subroutine. The original
; subroutine will then pop the stack and restore the original link address before returning.
;
; As much as I wanted to do this using only the original implementation instructions, it simply wasn't possible.
; There was no way to treat a register value as an address to store a value. So, opcodes D and E were added to
; store and load register values into an address stored in another register. This allows using one register as
; a stack pointer and store data to that address. Other registers are reserved to increment and decrement the
; stack pointer. The stack begins at memory address 0xFFFE (0xFFFF is the print address so can't be used) and grows down.
; There is no mechanism to check for an "out-of-bounds" stack. It's fully possible for the stack to overrun existing
; memory if care is not taken.

@bits 16
:main
    LOADI %A 0xFF
    LOADI %B 01
    LOADI %C FF
    LOADI %D FE

    ; Print H
    LOADI %1 'H'
    LOADI %F ~`e
    JMP %0 ~print

:e
    ; Print e
    LOADI %1 'e'
    LOADI %F ~`l
    JMP %0 ~print

:l
    ; Print ll
    LOADI %1 'l'
    LOADI %F ~`l2
    JMP %0 ~print

:l2
    LOADI %1 'l'
    LOADI %F ~`o
    JMP %0 ~print

:o
    ; Print o
    LOADI %1 'o'
    LOADI %F ~`end
    JMP %0 ~print

; Halt
:end
    HALT

; Subroutines

; return will jump to the address in the link register
; Wheeler jumps for the win!
:return
    ; Edit jump address in next instruction to the locaion in the link register
    STRA %E ~return_jmp+1
    STRA %F ~return_jmp+2
:return_jmp
    ; this instruction will always be edited to the value in the link register
    JMP %0 ~end

; Print the argument in R1
:print
    ; Push return address to stack
    STRR %C %E
    ADD %D %D %A
    STRR %C %F
    ADD %D %D %A

    ; Print arg 1
    STRA %1 0xFFFF

    ; Call another function for demo
    LOADI %F ~`print_return
    JMP %0 ~increment_F0

:print_return
    ; Pop return address from stack
    ADD %D %D %B
    LOADR %F %C
    ADD %D %D %B
    LOADR %E %C

    ; Return
    JMP %0 ~return

; increment_F0 is used to demonstrate a function call from a called function
; basically to show how the stack is used to save old link addresses and restored
; when the called function returns. Used by :print above
:increment_F0
    LOADA %1 0x00F0
    ADD %1 %1 %B
    STRA %1 0x00F0
    JMP %0 ~return
