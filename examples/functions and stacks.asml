; Print "Hello" using a print function
; Hello = x48 x65 x6C x6C x6F

; Reserved registers:
;   Register 0 = constant 0 - Used for unconditional jumps
;   Register C = constant -1 - Used to manipulate stack pointer
;   Register D = constant 1 - Used to manipulate stack pointer
;   Register E = stack pointer - Points to next available stack address
;   Register F = link register - Address to return when called functions finishes

; Functions are implemented by using what's known as a Wheeler jump. Basically, we edit the running
; code to change an address in a jump command. The address is retrieved from a known register so calling
; functions can set the return address to what they need. Labels are used liberally for return addresses.
; A stack is used to store link addresses when a subroutine has to call another subroutine. The original
; subroutine will then pop the stack and restore the original link address before returning.
;
; As much as I wanted to do this using only the original implementation instructions, it simply wasn't possible.
; There was no way to treat a register value as an address to store a value. So, opcodes D and E were added to
; store and load register values into an address stored in another register. This allows using one register as
; a stack pointer and store data to that address. Other registers are reserved to increment and decrement the
; stack pointer. The stack begins at memory address FE (FF is the print address so can't be used) and grows down.
; There is no mechanism to check for an "out-of-bounds" stack. It's fully possible for the stack to overrun existing
; memory if care is not taken.

:main
    LOADI %C 0xFFFF
    LOADI %D 01
    ; Stack starts at largest memory address minus 2
    LOADI %E 0xFFFC

    ; Print H
    LOADI %1 'H'
    LOADI %F ~e
    JMP %0 ~print

:e
    ; Print e
    LOADI %1 'e'
    LOADI %F ~l
    JMP %0 ~print

:l
    ; Print ll
    LOADI %1 'l'
    LOADI %F ~l2
    JMP %0 ~print

:l2
    LOADI %1 'l'
    LOADI %F ~o
    JMP %0 ~print

:o
    ; Print o
    LOADI %1 'o'
    LOADI %F ~end
    JMP %0 ~print

; Halt
:end
    HALT

; Subroutines

; return will jump to the address in register F
; Wheeler jumps for the win!
:return
    ; Edit jump address in next instruction to the locaion in register F
    STRA %F ~return_jump+2
:return_jump
    ; this instruction will always be edited to the value in register F
    JMP %0 ~end

; Print the argument in R1
:print
    ; Push return address to stack
    STRR %E %F
    ; Increment stack pointer by two
    ADD %E %E %C
    ADD %E %E %C

    ; Print arg 1
    STRA %1 0xFFFE

    ; Call another function for demo
    LOADI %F ~print_return
    JMP %0 ~increment_F0

:print_return
    ; Pop return address from stack
    ; Decrement stack pointer by two
    ADD %E %E %D
    ADD %E %E %D
    LOADR %F %E

    ; Return
    JMP %0 ~return

; increment_F0 is used to demonstrate a function call from a called function
; basically to show how the stack is used to save old link addresses and restored
; when the called function returns. Used by :print above
:increment_F0
    LOADA %1 F0
    ADD %1 %1 %D
    STRA %1 F0
    JMP %0 ~return
